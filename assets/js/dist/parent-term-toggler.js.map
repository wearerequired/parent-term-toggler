{"version":3,"sources":["../src/parent-term-toggler.js"],"names":["window","$","jQuery","ParentTermToggler","taxonomy","$metabox","event","$el","currentTarget","closest","length","id","attr","replace","termIsChild","stopWatch","isChecked","is","traverseParentTermsAndSetChecked","watch","checked","parents","each","index","element","$term","parent","find","eq","prop","trigger","on","toggle","bind","off","_ParentTermTogglerSettings","supportedTaxonomies","forEach","toggler"],"mappings":";;;;;;AAAA;;cAEsBA,M;IAANC,C,WAARC,M;;IAEFC,iB;AACL;;;;;AAKA,4BAAaC,QAAb,EAAwB;AAAA;;AACvB,OAAKA,QAAL,GAAgBA,QAAhB;AACA,OAAKC,QAAL,GAAgBJ,QAAOG,QAAP,SAAhB;AACA;;AAED;;;;;;;;;yBAKQE,K,EAAQ;AACf,OAAIC,MAAMN,EAAGK,MAAME,aAAT,CAAV;;AAEA;AACA,OAAKD,IAAIE,OAAJ,CAAa,qBAAb,EAAqCC,MAA1C,EAAmD;AAClD,QAAMC,KAAKJ,IAAIK,IAAJ,CAAU,IAAV,EAAiBC,OAAjB,CAA0B,UAA1B,EAAsC,EAAtC,CAAX;AACAN,UAAMN,QAAOU,EAAP,CAAN;AACA;;AAED;AACA,OAAK,CAAE,KAAKG,WAAL,CAAkBP,GAAlB,CAAP,EAAiC;AAChC;AACA;;AAED;AACA,QAAKQ,SAAL;;AAEA,OAAMC,YAAYT,IAAIU,EAAJ,CAAQ,UAAR,CAAlB;AACA,QAAKC,gCAAL,CAAuCX,GAAvC,EAA4CS,SAA5C;;AAEA;AACA,QAAKG,KAAL;AACA;;AAED;;;;;;;;;mDAMkCZ,G,EAAsB;AAAA,OAAjBa,OAAiB,uEAAP,IAAO;;AACvDb,OAAIc,OAAJ,CAAa,WAAb,EAA2BC,IAA3B,CAAiC,UAAEC,KAAF,EAASC,OAAT,EAAsB;AACtD,QAAMC,QAAQxB,EAAGuB,OAAH,EAAaE,MAAb,CAAqB,IAArB,EAA4BC,IAA5B,CAAkC,wBAAlC,EAA6DC,EAA7D,CAAiE,CAAjE,CAAd;;AAEA,QAAKR,YAAYK,MAAMI,IAAN,CAAY,SAAZ,CAAjB,EAA2C;AAC1C;AACA;;AAEDJ,UAAMK,OAAN,CAAe,OAAf;AACA,IARD;AASA;;AAED;;;;;;;;;8BAMavB,G,EAAM;AAClB,UAAOA,IAAIE,OAAJ,CAAa,WAAb,EAA2BC,MAA3B,GAAoC,CAA3C;AACA;;AAED;;;;;;0BAGQ;AACP,QAAKL,QAAL,CAAc0B,EAAd,CAAkB,4BAAlB,EAAgD,wBAAhD,EAA0E,KAAKC,MAAL,CAAYC,IAAZ,CAAkB,IAAlB,CAA1E;AACA;;AAED;;;;;;8BAGY;AACX,QAAK5B,QAAL,CAAc6B,GAAd,CAAmB,4BAAnB;AACA;;;;;;AAGFjC,EAAG,YAAM;AACR;AACAkC,4BAA2BC,mBAA3B,CAA+CC,OAA/C,CAAwD,UAAEjC,QAAF,EAAgB;AACvE,MAAIkC,UAAU,IAAInC,iBAAJ,CAAuBC,QAAvB,CAAd;AACAkC,UAAQnB,KAAR;AACA,EAHD;AAIA,CAND","file":"parent-term-toggler.js","sourcesContent":["/* global _ParentTermTogglerSettings */\n\nconst { jQuery: $ } = window;\n\nclass ParentTermToggler {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} taxonomy - The taxonomy name.\n\t */\n\tconstructor( taxonomy ) {\n\t\tthis.taxonomy = taxonomy;\n\t\tthis.$metabox = $( `#${taxonomy}div` );\n\t}\n\n\t/**\n\t * Toggle handler for change events.\n\t *\n\t * @param {object} event - Change event.\n\t */\n\ttoggle( event ) {\n\t\tlet $el = $( event.currentTarget );\n\n\t\t// Change $el if a popular term is selected.\n\t\tif ( $el.closest( 'li.popular-category' ).length ) {\n\t\t\tconst id = $el.attr( 'id' ).replace( 'popular-', '' );\n\t\t\t$el = $( `#${id}` );\n\t\t}\n\n\t\t// Ignore changes to non-child terms.\n\t\tif ( ! this.termIsChild( $el ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop watching to avoid recursion.\n\t\tthis.stopWatch();\n\n\t\tconst isChecked = $el.is( ':checked' );\n\t\tthis.traverseParentTermsAndSetChecked( $el, isChecked );\n\n\t\t// Start watching again.\n\t\tthis.watch();\n\t}\n\n\t/**\n\t * Gets all parent terms and (un)checks them.\n\t *\n\t * @param {object} $el - The jQuery element.\n\t * @param {boolean} checked - Whether the terms should be checked.\n\t */\n\ttraverseParentTermsAndSetChecked( $el, checked = true ) {\n\t\t$el.parents( '.children' ).each( ( index, element ) => {\n\t\t\tconst $term = $( element ).parent( 'li' ).find( 'input[type=\"checkbox\"]' ).eq( 0 );\n\n\t\t\tif ( checked === $term.prop( 'checked' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$term.trigger( 'click' );\n\t\t} );\n\t}\n\n\t/**\n\t * Whether a term has parent terms.\n\t *\n\t * @param {object} $el - The jQuery element.\n\t * @returns {boolean} True if a term has parent terms, false if not.\n\t */\n\ttermIsChild( $el ) {\n\t\treturn $el.closest( '.children' ).length > 0;\n\t}\n\n\t/**\n\t * Attaches an event handler for checkbox changes.\n\t */\n\twatch() {\n\t\tthis.$metabox.on( 'change.parent-term-toggler', 'input[type=\"checkbox\"]', this.toggle.bind( this ) )\n\t}\n\n\t/**\n\t * Removes the event handler for checkbox changes.\n\t */\n\tstopWatch() {\n\t\tthis.$metabox.off( 'change.parent-term-toggler' );\n\t}\n}\n\n$( () => {\n\t// Create a Toggler instance for each supported taxonomy.\n\t_ParentTermTogglerSettings.supportedTaxonomies.forEach( ( taxonomy ) => {\n\t\tlet toggler = new ParentTermToggler( taxonomy );\n\t\ttoggler.watch();\n\t} );\n} );\n"]}